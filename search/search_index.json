{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Welcome to the Equilibria docs. This page is for developers and those looking to contribute to the repo.</p> <p>You can install funding-rate-arbitrage from source with:</p> <pre><code>git clone https://github.com/50shadesofgwei/funding-rate-arbitrage.git\ncd funding-rate-arbitrage\npython3 -m pip install -e\n</code></pre> <p>After you have installed the Equilibria engine, start the bot with Quickstart</p>"},{"location":"#equilibria-stack","title":"Equilibria Stack","text":""},{"location":"Disclaimer/","title":"Legal Disclaimer","text":"<p>This repository is under active development and has not yet been ran extensively in production. By cloning or forking the code and running it locally, you understand that you are running in-development code, and take on all responsibility for any loss of funds that are incurred via user error, as-of-yet-undiscovered bugs, or any other concievable reason. You should be comfortable running, interacting with and debugging the bot on testnet before considering any runs with real capital. This project is for educational purposes only. Any interested party should not construe any information or other material found in this repository as legal, tax, investment, financial, or other advice. Nothing contained here constitutes a solicitation, recommendation, endorsement, or offer by the repository creator, the Synthetix Protocol, or any third party service provider to buy or sell any securities or other financial instruments in the US, nor in any other jurisdiction in which such solicitation or offer would be unlawful under the securities laws of said jurisdiction. Under no circumstances will the repository creator or the Synthetix or GMX Protocols be held responsible or liable in any way for any claims, damages, losses, expenses, costs, or liabilities whatsoever, including, without limitation, any direct or indirect damages for loss of profits.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#architecture","title":"Architecture","text":"<p>The project is designed according to a modular, event-driven architecture where functionality is grouped together into like kind sub-classes, instances of which are then contained in a master class which itself is contained within the main class. To illustrate, let's look at the APICaller module contains all logic for calling funding rate data from the relevant APIs. This module contains two sub-classes <code>SynthetixCaller</code> and <code>BinanceCaller</code>, where all the logic for interacting with the respective APIs is stored in the corresponding sub-class. Then an instance of each class is stored within the <code>MasterCaller</code> class, which contains all functions that require access to both of these APIs, an example being reading and identifying funding rate discrepancies between the two. This inheritance structure is repeated with the Master modules, an instance of each being created in the Main class. The Main class therefore contains instances of the following:     - <code>MasterCaller</code>     - <code>MatchingEngine</code>     - <code>MasterPositionMonitor</code>     - <code>MasterPositionController</code>     - <code>TradeLogger</code></p> <p>Cross-module communication is handled via event emitters and listeners, a directory of which can be found in GlobalUtils.py. Upon confirmation of execution, trades are logged to a database with each side (SNX/HMX) having its own entry, and are linked via a shared UUID. Upon closing, the entries are updated with relevant PnL, accrued funding and reason for close. </p> <pre><code>flowchart TD\n    %% Core Orchestrator\n    subgraph \"Core Orchestrator\"\n        Main[\"Main (Entry Point)\"]:::main\n    end\n\n    %% Modules\n    subgraph \"Modules\"\n        direction TB\n        APICaller[\"APICaller\"]:::api\n        MatchingEngine[\"MatchingEngine\"]:::matching\n        PositionMonitor[\"PositionMonitor\"]:::monitor\n        TxExecution[\"TxExecution\"]:::execution\n        Backtesting[\"Backtesting\"]:::backtesting\n        GlobalUtils[\"GlobalUtils\"]:::utils\n    end\n\n    %% External Exchanges\n    subgraph \"External Exchanges\"\n        direction TB\n        Binance[\"Binance\"]:::exchange\n        ByBit[\"ByBit\"]:::exchange\n        GMX[\"GMX\"]:::exchange\n        HMX[\"HMX\"]:::exchange\n        OKX[\"OKX\"]:::exchange\n        Perennial[\"Perennial\"]:::exchange\n        Synthetix[\"Synthetix\"]:::exchange\n    end\n\n    %% Relationships\n    Main --&gt; APICaller\n    Main --&gt; MatchingEngine\n    Main --&gt; PositionMonitor\n    Main --&gt; TxExecution\n    Main --&gt; Backtesting\n    Main --&gt; GlobalUtils\n\n    APICaller --&gt;|\"funding_data\"| MatchingEngine\n    MatchingEngine --&gt;|\"trade_signals\"| PositionMonitor\n    MatchingEngine --&gt;|\"trade_signals\"| TxExecution\n\n    APICaller --&gt;|\"api_calls\"| Binance\n    APICaller --&gt;|\"api_calls\"| ByBit\n    APICaller --&gt;|\"api_calls\"| GMX\n    APICaller --&gt;|\"api_calls\"| HMX\n    APICaller --&gt;|\"api_calls\"| OKX\n    APICaller --&gt;|\"api_calls\"| Perennial\n    APICaller --&gt;|\"api_calls\"| Synthetix\n\n    MatchingEngine -.-&gt;|\"utilizes\"| GlobalUtils\n    PositionMonitor -.-&gt;|\"logs_via\"| GlobalUtils\n    TxExecution -.-&gt;|\"executes_using\"| GlobalUtils\n\n    %% Click Events\n    click Main \"https://github.com/50shadesofgwei/funding-rate-arbitrage/blob/main/Main/main_class.py\"\n    click APICaller \"https://github.com/50shadesofgwei/funding-rate-arbitrage/blob/main/APICaller/master/MasterCaller.py\"\n    click Binance \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/Binance/\"\n    click ByBit \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/ByBit/\"\n    click GMX \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/GMX/\"\n    click HMX \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/HMX/\"\n    click OKX \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/Okx/\"\n    click Perennial \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/Perennial/\"\n    click Synthetix \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/APICaller/Synthetix/\"\n    click Backtesting \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/Backtesting/\"\n    click MatchingEngine \"https://github.com/50shadesofgwei/funding-rate-arbitrage/blob/main/MatchingEngine/MatchingEngine.py\"\n    click PositionMonitor \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/PositionMonitor/\"\n    click TxExecution \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/TxExecution/\"\n    click GlobalUtils \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/GlobalUtils/\"\n    click Assets \"https://github.com/50shadesofgwei/funding-rate-arbitrage/tree/main/Assets/\"\n    click Contributors \"https://github.com/50shadesofgwei/funding-rate-arbitrage/blob/main/Contributors/README.md\"\n\n    %% Styles\n    classDef main fill:#FFD700,stroke:#DAA520,stroke-width:2px\n    classDef api fill:#ADD8E6,stroke:#0000FF,stroke-width:2px\n    classDef matching fill:#FFFF99,stroke:#FFD700,stroke-width:2px\n    classDef monitor fill:#FFA07A,stroke:#FF4500,stroke-width:2px\n    classDef execution fill:#FFB6C1,stroke:#FF69B4,stroke-width:2px\n    classDef backtesting fill:#D8BFD8,stroke:#DA70D6,stroke-width:2px\n    classDef utils fill:#90EE90,stroke:#32CD32,stroke-width:2px\n    classDef exchange fill:#E6E6FA,stroke:#8A2BE2,stroke-width:2px\n    classDef doc fill:#F0E68C,stroke:#BDB76B,stroke-width:2px</code></pre>"},{"location":"backtesting/","title":"Backtesting","text":""},{"location":"backtesting/#backtesting","title":"Backtesting","text":"<p>New module introduced in v0.2.0 - fetches, parses, and runs backdated strategies on any asset in the <code>TARGET_TOKENS</code> enum. Some helper functions are included, mainly to abstract away the process of calling the <code>MarketProxy</code> contract for historical funding rate data. This is done in one call, and sorted by asset + block number before being written to local storage in the relevant JSON file. Upon analysis, this data is parsed into pandas DataFrames which makes running the tests easier - The current model runs for one asset at a time, entering a position when the discrepancy in funding rates rises above a given bound, and closes the position when it falls back below.</p> <p>From some initial runs, we find a handful of useful results:  First of all that the funding rate on the Synthetix market is much more volatile than the Binance equivalent, which tells us that we will in most cases be taking the Synthetic position as the 'yield farm' and the Binance position as the hedge.</p> <p>A visualisation of the strategy would look like the following:  We see that the strategy is generally functioning well, but shows that there are many optimisations that we can make. Timing the trade to get out before the funding rate flips, and therefore avoiding some of the <code>taker</code> fees in favour of the lower <code>maker</code> fees. This part of the repo is free to play around with, and tinkering with strategies, leverage numbers, entry and exit conditions is highly encouraged.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#video-walkthrough","title":"Video Walkthrough","text":"<p>A high level walkthrough can be found via following this link: Watch here</p>"},{"location":"concepts/#profitability-estimations","title":"Profitability Estimations","text":"<p>As of version 0.2.1, the impact of a potential trade on funding velocity is now taken into consideration when assessing the profitability of a position - maker/taker fees are also taken into account, and 8 new markets have been added to the searcher algorithm (by default, all will be selected). More markets will be added in future releases as they amass sufficient liquidity.</p> <p>To estimate the profit for a trade we start with the Synthetix half - the trade details are generated by the MatchingEngine module and passed to CheckProfitability.py, where the user's <code>BASE_TRADE_SIZE_USD</code> is multiplied by their <code>TRADE_LEVERAGE</code> to find the total dollar value of the position. The market price of the asset is then called, and the dollar value converted into the amount of the asset in question which is halved, giving us the trade size per trade leg and finally we adjust for the side (long or short) of each trade and factor in the expected price impact.  Now that we have the size of the position we are going to place on Synthetix, the next step is to calculate the effect that our trade will have on the funding velocity of the respective market. To do this, we use the <code>skew</code> value in our <code>opportunity</code> object along with the our trade size, and pass these as arguments to a helper function that will return the funding velocity after our trade is placed: <pre><code>@staticmethod\n    def calculate_new_funding_velocity(symbol: str, current_skew: float, trade_size: float) -&gt; float:\n        try:\n            market_data = MarketDirectory.get_market_params(symbol)\n            c = market_data['max_funding_velocity'] / market_data['skew_scale']\n            new_skew = current_skew + trade_size\n            new_funding_velocity = c * new_skew\n            return new_funding_velocity\n        except Exception as e:\n            raise ValueError(f\"GlobalUtils - Failed to calculate new funding velocity for {symbol}: {e}\")\n</code></pre> Funding velocity is defined as the product of the formula $dr/dt=c*skew$, where $dr/dt$ is the velocity, $c$ is the constant factor $(maxFundingVelocity / skewScale)$, and $skew$ is the measure of the imbalance between long and short open interest in the given market, measured in units of said asset. </p> <p>(If this is a bit abstract, there's a good blog post that you can find here with some more intuitive explanations)</p> <p>So to calculate the new funding velocity we solve for the above function by grabbing the market details from the <code>MarketDirectory</code> class, which will be of type: <pre><code>'ETH': {\n        'market_id': 100,\n        'symbol': 'ETH',\n        'max_funding_velocity': 9,\n        'skew_scale': 350000,\n        'maker_fee': 0.000001,\n        'taker_fee': 0.0005\n    }\n</code></pre> from which we calculate our constant factor and our new funding velocity.</p> <p>Now that we have our funding velocity, we have to do some further calculations to give us an estimate of how long it will take before the funding rate turns against our trade. Fundamentally, the velocity figure shows us where the funding rate will be in 24 hours' time assuming no other trades are placed within that period. To visualise this, we can illustrate the funding rate over time on a chart like so:  Where the green shaded area is our profit, and the funding velocity is represented by the gradient of the funding rate value over time. As we can see, once our trade is placed a new funding rate velocity is calculated and the gradient of the line changes; in this example there is already a negative funding velocity (funding rate is headed downwards), and our short trade increases the rate at which this change is occuring. You can visualise the profit as the sum of the green shaded area.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Once you have cloned the repo and installed all dependencies navigate to the .env file and input the necessary values. You will need:</p> <ul> <li>An Alchemy API key (Base + Arbitrum)</li> <li>The relevant chainId (Base Mainnet: 8453, Base Testnet: 84532)</li> <li>Your wallet address and Private Key (For security reasons you should create a new wallet to use here)</li> </ul> <p>Some recommended values for the following vars are as follows: - <code>TRADE_LEVERAGE=5</code> - <code>DELTA_BOUND=0.03</code> - <code>PERCENTAGE_CAPITAL_PER_TRADE=50</code></p> <p>The vars: - <code>DEFAULT_TRADE_DURATION_HOURS=8</code> and - <code>DEFAULT_TRADE_SIZE_USD=250</code> are there for determining the most profitable opportinity. The actual size of your trades will be determined by how much collateral is in your accounts, the leverage factor, and the percentage capital per trade.</p> <p>Trade Leverage specifies the leverage applied to the collateral amount on each trade. Setting this value too high will result in positions being liquidated, so keeping a relatively small cap is a good idea. Delta Bound calculates the maximum delta on a trade pair before it will be cancelled by the health checker. The delta between positions will in most cases be 0.0, so this is mostly a failsafe. Percentage Capital Per Trade specifies the amount of available capital to be used on each trade that is executed. This is derived by checking how much available collateral there is on each exchange, then taking the smaller value and calculating <code>(smallerValue/100)*PERCANTAGE_CAPITAL_PER_TRADE</code>. Higher values for this will of course make the trade sizes larger, and therefore will mean having to rebalance the collateral between exchanges more frequently.</p> <p>In addition, you can choose which tokens to target/exclude from the searching algorithm via navigating to <code>APICaller.master.MasterUtils.py</code>, where you will find an array that looks like this: <pre><code>TARGET_TOKENS = [\n    {\"token\": \"BTC\", \"is_target\": True},\n    {\"token\": \"ETH\", \"is_target\": True},\n]\n</code></pre> To include/exclude a token, simply replace <code>True</code> with <code>False</code> and vice versa. The above example targets both BTC and ETH, but if for the sake of argument we only wanted to target ETH, we'd edit the array to look like the following: <pre><code>TARGET_TOKENS = [\n    {\"token\": \"BTC\", \"is_target\": False},\n    {\"token\": \"ETH\", \"is_target\": True},\n]\n</code></pre> The bot will now only target ETH opportunities.</p> <p>To switch between which exchanges are targeted, there is a similar array: <pre><code>TARGET_EXCHANGES = [\n    {\"exchange\": \"GMX\", \"is_target\": True},\n    {\"exchange\": \"Synthetix\", \"is_target\": True},\n]\n</code></pre> It's currently recommended that you run with exchanges GMX, Synthetix, and ByBit. Note that some additional steps are required before executing trades, namely that a Synthetix perps account will have to be created and have some collateral deployed. The code for this is found in the next section.</p>"},{"location":"getting-started/#testnet-config","title":"Testnet config","text":"<p>To start executing some test trades, first you will need to mint some fUSDC on Base sepolia (you can do that here by calling <code>deposit_eth</code> with some testnet Eth and '0xc43708f8987Df3f3681801e5e640667D86Ce3C30' as the token_address argument).  After you have some fUSDC, you can call the collateral deposit function by running the <code>deploy-collateral</code> command in the CLI. Once you click enter it will ask you for the amount to deposit. Amount is denominated in USD, so to deposit 100 USDC, you'd enter the command as follows: <code>deploy-collateral 100</code></p> <p>For the Binance side, you will have to create an account and set of API keys here, and use these keys in the .env file. Additionally, whether the Binance client is set to testnet or live trading is determined upon initialisation of the Binance clients. By default they will target testnet and look like so:</p> <pre><code>self.client = Client(api_key, api_secret, base_url=\"https://testnet.binancefuture.com\")\n</code></pre> <p>To switch to live trading, simply remove the final argument like so:</p> <pre><code>self.client = Client(api_key, api_secret)\n</code></pre> <p>As of version 0.3.0, there are Binance clients initialised in the following files. Make sure all are configured uniformly.     - BinanceCaller.py     - BinancePositionController.py     - BinancePositionMonitor.py</p>"},{"location":"roadmap/","title":"Project Roadmap","text":"<p>Last updated: 2025-04-02</p>"},{"location":"roadmap/#vision-statement","title":"Vision Statement","text":"<p>Democratize high frequency trading for everyone.</p>"},{"location":"roadmap/#milestones","title":"Milestones","text":""},{"location":"roadmap/#m1-clean-repo-target-eom","title":"M1 - [Clean Repo] (Target: EOM)","text":"<ul> <li>[ ] Loosely coupled codebase</li> <li>[ ] Setup up Github Actions Testing pipeline with pytest</li> </ul>"},{"location":"roadmap/#m2-maintain-exchange-integration","title":"M2 - [Maintain Exchange Integration]","text":"<ul> <li>[ ] Review and test existing connectors</li> </ul>"},{"location":"roadmap/#m3-easy-engine-deployment","title":"M3 - [Easy Engine Deployment]","text":"<ul> <li>[ ] Dockerfile to run on any cloud platform</li> </ul>"},{"location":"roadmap/#m4-build-clients","title":"M4 - [Build Clients]","text":"<ul> <li>[ ] Web Client</li> <li>[ ] Desktop Client</li> <li>[ ] Mobile Client</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#cli-commands","title":"CLI Commands","text":"<ul> <li><code>project-run</code>: Start the bot.</li> <li><code>project-run-demo</code>: Search opportunities without executing trades</li> <li><code>deploy-collateral-synthetix [amount]</code> Deposit collateral to Synthetix</li> <li><code>deploy-collateral-gmx [amount]</code> Deposit collateral to GMX</li> </ul>"},{"location":"usage/#switching-networks","title":"Switching networks","text":"<p>Edit <code>.env</code></p> <ul> <li>Testnet <code>CHAIN_ID=84532</code></li> <li>Mainnet: <code>CHAIN_ID=8453</code></li> </ul>"},{"location":"usage/#configuring-tokens","title":"Configuring Tokens","text":"<p>Modify <code>APICaller/master/MasterUtils.py</code>:</p> <pre><code>TARGET_TOKENS = [\n    {\"token\": \"BTC\", \"is_target\": True},\n    {\"token\": \"ETH\", \"is_target\": False},\n]\n</code></pre>"},{"location":"quickstart/v1-client/","title":"GMX Arbitrage Client","text":"<p>The v1 client is our first client that interface with the engine.</p> <p>This client was built in order to win a grant from GMX.</p> <p>This engine is located in the <code>backend-flask-server</code> branch and hosted temporarily (running on free AWS credits) on the web at <code>https://fundingratesniper.com</code>.</p>"},{"location":"quickstart/v1-client/#starting-the-client-locally","title":"Starting the client locally","text":"<p><code>git clone git@github.com:PrabodhGyawali/GMX-Arb-UI.git</code></p> <p><code>cd GMX-Arb-UI</code></p> <p><code>npm install</code></p> <p><code>npm start</code></p> <p>This should allow you to use the repo in the browser.</p>"},{"location":"quickstart/v1-client/#starting-the-backend-flask-server-version-of-the-engine","title":"Starting the <code>backend-flask-server</code> version of the engine","text":"<p><code>git clone https://github.com/50shadesofgwei/funding-rate-arbitrage -b backend-flask-server gmx-engine</code></p> <p><code>cd gmx-engine</code></p>"},{"location":"quickstart/v1-client/#install-dependencies-in-your-python-environment","title":"Install dependencies in your python environment","text":"<p><code>pip install -e .</code></p> <p><code>mv example.env .env</code></p> <p><code>project-run-ui</code></p>"}]}